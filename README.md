# Coding War Crime - A War Crimes Documentation

A collection of small code snippets, experiments, and **intentional coding atrocities**. This repo documents my journey as a long-term learner by deliberately writing terrible code to understand *why* we don't do things this way.

---

## âš ï¸ WARNING: Blasphemy Against Coding Ahead.

**This code is intentionally bad.** Every file in this repo violates best practices, ignores optimization, and makes seasoned developers cry. The goal is simple: learn by breaking all the rules, then understanding exactly why those rules exist.

If you're looking for production-ready code, turn back now. If you want to see creative ways to make Python suffer, you're in the right place.

---

## Philosophy

> "To truly appreciate good code, you must first write spectacularly bad code on purpose."

This repo explores:
- **Anti-patterns as learning tools** - Understanding why something is wrong teaches more than just doing it right
- **First principles thinking** - Reimplementing basic operations from scratch (even when we shouldn't)
- **Algorithmic horror** - Data structures that violate every complexity class
- **Cursed creativity** - Combining concepts that should never be combined

No strict curriculum. No deadlines. Just curiosity-driven chaos and long-term learning.

---

## What Makes This Different

Everyone builds todo apps and sorting algorithms. This repo asks: "What if we built them *wrong* on purpose?"
- Nested ternaries instead of if statements
- String manipulation instead of math
- O(nÂ²) solutions when O(1) exists
- ASCII arithmetic because why not suffer?

Each war crime comes with:
- âœ… Comprehensive comments explaining the horror
- âœ… Complexity analysis showing how bad it really is
- âœ… The "correct way" for comparison
- âœ… Educational value buried under the chaos

---

## Structure
```
tiny-cs-projcets/
â”œâ”€â”€ README.md
â”œâ”€â”€ MIT license.md
â””â”€â”€ days/
    â”œâ”€â”€ day_001__FizzBuzz.py
    â”œâ”€â”€ days_002__war_calculator.py
    â”œâ”€â”€ days_003__worse_bogosort.py
    â”œâ”€â”€ days_004__linierly_linked_hashmap.py
    â”œâ”€â”€ days_005__Boolean_with_ARITHMETIC.py
    â”œâ”€â”€ days_006__Cursive_for_loop.py
    â”œâ”€â”€ days_007__JSON_REGEX_parser.py
    â”œâ”€â”€ days_008__non_binary_search.py
    â”œâ”€â”€ days_009__comrade_fibonacci.py
    â”œâ”€â”€ days_010__goodbye_world.py
    â”œâ”€â”€ days_011__singleton_aint_single.py
    â”œâ”€â”€ days_012__in_a_pickle_data.py
    â”œâ”€â”€ days_013__permanent_rest_API.py
    â”œâ”€â”€ days_014__exceptional_error.py
    â”œâ”€â”€ days_016__Null_fit_check
    â”œâ”€â”€ days_017__Reversed_bit_roles.py
    â”œâ”€â”€ days_018__too_much_thread.py
    â”œâ”€â”€ days_019__OOPsie_daisy.py
    â”œâ”€â”€ days_020__de_Q_stack
    â”œâ”€â”€ days_021__stack_wrestling.py
    â”œâ”€â”€ days_022__binary__tree_street.py
    â”œâ”€â”€
    â””â”€â”€
```

---

## Daily Log

- **Day 001** (2025-01-07) - **FizzBuzz** but every condition is a nested ternary operator (no if statements allowed)
- **Day 002** (2025-01-08) - **Calculator** that converts all numbers to strings, does string manipulation, then converts back
- **Day 003** (2025-01-09) - **Sorting algorithm** that just shuffles randomly until it's sorted (bogosort but worse)
- **Day 004** (2025-01-10) - **Hash Map** implemented with a linked List
- **Day 005** (2025-01-11) - **Boolean logic** using only arithmetic operations (True = 1, False = 0, and statements become multiplication)
- **Day 006** (2025-01-12) - **For loop** implemented using recursion and global variables
- **Day 007** (2025-01-13) - **JSON parser** using only regex and string.replace()
- **Day 008** (2025-01-14) - **Binary search** that checks every element anyway "just to be sure"
- **Day 009** (2025-01-15) - **Fibonacci** that recalculates from scratch every single time (no memoization, maximum pain)
- **Day 010** (2025-01-16) - **Hello World** but it's generated by a 500-line function
- **Day 011** (2025-01-17) - **Singleton pattern** implemented by storing everything in a text file
- **Day 012** (2025-01-18) - **Database** that's just one giant pickled dictionary rewritten on every operation
- **Day 013** (2025-01-19) - **REST API** where every endpoint is a POST and the verb is in the body
- **Day 014** (2025-01-20) - **Error handling** using exceptions for control flow
- **Day 015** (2025-01-21) - **Variable names** that are just Unicode emojis
- **Day 016** (2025-01-22) - **Null check** that catches exceptions instead of using if statements
- **Day 017** (2025-01-23) - **String reversal** by converting to binary, reversing bits, then back
- **Day 018** (2025-01-24) - **Threading** for a single print statement
- **Day 019** (2025-01-25) - **OOP** where every function is its own class with one method
- **Day 020** (2025-01-26) - **Stack** implemented as a queue (dequeue from wrong end every time)
- **Day 021** (2025-01-27) - **Queue** implemented as two stacks that fight each other
- **Day 022** (2025-01-28) - **Binary tree** stored as a single comma-separated string

---

## Contributing

Found an even worse way to do something? Have a suggestion for a new war crime? Feel free to:
- Open an issue with your cursed idea
- Comment on existing files with code reviews
- Share your own horror stories

Just remember: all contributions must be **intentionally educational**, not accidentally bad.

---

## Why This Exists

**For me:** Deliberate practice in understanding *why* best practices exist. Writing bad code on purpose forces you to think about tradeoffs, complexity, and the value of abstraction.

**For you:** Entertainment, learning, and a reminder that "clever" code is usually just "bad" code in disguise.

**For the world:** So future generations can look back and say "at least we learned from our mistakes."

---

## Weekly Updates

Follow along as I document these crimes on LinkedIn under #CodingWarCrimes. Every week I'll share:
- The worst things I coded
- Why you should never do them
- What I actually learned
- Bonus: comparisons showing the "right way"

**Goal:** Get featured in the Geneva Conventions as an honorary member for crimes against computer science. ðŸŽ¯

---

## Disclaimer

**DO NOT:**
- Use this code in production
- Show it to your CS professor (unless they have a sense of humor)
- Learn from this as if it's correct
- Submit this as homework

**DO:**
- Learn why each approach is terrible
- Appreciate your language's built-in features
- Laugh at the absurdity
- Share your favorite war crimes with others

---

## License

MIT License - Use this code however you want, but please don't actually use it.

If this code causes your production system to crash, you ignored multiple warnings and honestly deserve what you got.

---

*"Any sufficiently advanced debugging is indistinguishable from war crimes."* - Not Arthur C. Clarke

**Remember:** This is a learning journey through terrible code. The real education is understanding why every single line is wrong.

Want to follow the chaos? Check the Daily Log above, or browse the `days/` folder if you dare. ðŸ”¥
